import ChainAbstractionIntro from '../../shared/chain-abstraction-intro.mdx'

# Chain Abstraction

<ChainAbstractionIntro />

## Methods

The following methods from WalletKit are used in implementing chain abstraction.

:::note
ðŸ’¡ Chain abstraction is currently in the early access phase
:::

### Prepare 

This method is used to check if chain abstraction is needed. If it is, it will return a response with the necessary transactions. 
If it is not, it will return a response with the original transaction. 

```dart
Future<PrepareDetailedResponseCompat> prepare({
  required String chainId,
  required String from,
  required CallCompat call,
  Currency? localCurrency,
});
```

### Execute

This method is used to execute the chain abstraction operation. The method will handle broadcasting all transactions in the correct order and monitor the cross-chain transfer process. It returns an `ExecuteDetails` object with the transaction status and results.

```dart
Future<ExecuteDetailsCompat> execute({
  required UiFieldsCompat uiFields,
  required List<String> routeTxnSigs,
  required String initialTxnSig,
})
```

## Usage

When sending a transaction, first check if chain abstraction is needed using the `prepare` method. Call the `execute` method to broadcast the routing and initial transactions and wait for it to be completed. 

If the operation is successful, you need to broadcast the initial transaction and await the transaction hash and receipt. 
If the operation is not successful, send a JsonRpcError to the dapp and display the error to the user. 

```swift
final response = await _walletKit.prepare(
  chainId: chainId, // selected chain id
  from: from, // sender address
  call: CallCompat(
    to: to, // contract address
    input: input, // calldata
  ),
);
response.when(
  success: (PrepareDetailedResponseSuccessCompat deatailResponse) {
    deatailResponse.when(
      available: (UiFieldsCompat uiFieldsCompat) {
        // If the route is available, present a CA transaction UX flow and sign hashes when approved
        final TxnDetailsCompat initial = uiFieldsCompat.initial;
        final List<TxnDetailsCompat> route = uiFieldsCompat.route;
        
        final String initialSignature = signHashMethod(initial.transactionHashToSign);
        final List<String> routeSignatures = route.map((route) {
          final String rSignature = signHashMethod(route.transactionHashToSign);
          return rSignature;
        }).toList();

        return await _walletKit.execute(
          uiFields: uiFields,
          initialTxnSig: initialSignature,
          routeTxnSigs: routeSignatures,
        );
      },
      notRequired: (PrepareResponseNotRequiredCompat notRequired) {
        // user does not need to move funds from other chains
        // proceeds as normal transaction with notRequired.initialTransaction
      },
    );
  },
  error: (PrepareResponseError prepareError) {
    // Show an error
    // contains prepareError.error as BridgingError and could be either:
    // noRoutesAvailable, insufficientFunds, insufficientGasFunds
  },
);
```

For example, check out implementation of chain abstraction in [sample wallet](https://github.com/reown-com/reown_flutter/blob/develop/packages/reown_walletkit/example/lib/dependencies/chain_services/evm_service.dart) with Flutter.

## Testing 

Best way to test Chain Abstraction is to use our Sample wallet.
- [Sample Wallet for iOS](https://testflight.apple.com/join/Uv0XoBuD)
- [Sample Wallet for Android](https://appdistribution.firebase.dev/i/2b8b3dce9e2831cd)

You can also use the [AppKit laboratory](https://appkit-lab.reown.com/library/wagmi/) and try sending [USDC/USDT](../../../walletkit/features/early-access/chain-abstraction.mdx#what-are-the-supported-tokens-and-networks) with any chain abstraction-supported wallet. 

<video controls width="100%" height="100%" style={{ borderRadius: '10px' }}>
  <source src="/assets/chain-abstraction-demo.mp4" type="video/mp4" />
</video>
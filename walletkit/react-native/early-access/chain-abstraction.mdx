---
title: Chain Abstraction
---

<Info>
ðŸ’¡ Chain Abstraction is currently in early access phase. 
</Info>

Chain Abstraction in WalletKit enables users with stablecoins on any network to spend them on-the-fly on a different network. Our Chain Abstraction solution provides a toolkit for wallet developers to integrate this complex functionality using WalletKit.

For example, when an app requests a 100 USDC payment on Base network but the user only has USDC on Arbitrum, WalletKit offers methods to detect this mismatch, generate necessary transactions, track the cross-chain transfer, and complete the original transaction after bridging finishes.


## How It Works

<Info>
Apps need to pass `gas` as null when sending a transaction to allow proper gas estimation by the wallet. Refer to this [guide](../../../appkit/next/early-access/chain-abstraction) for more details.
</Info>

When sending a transaction, you need to:
1. Check if the required chain has enough funds to complete the transaction
2. If not, use the `prepare` method to generate necessary bridging transactions
3. Check the status of the bridging transactions and wait for them to complete
4. Once the bridging transactions are completed, execute the initial transaction

The following sequence diagram illustrates the complete flow of a chain abstraction operation, from the initial dapp request to the final transaction confirmation

<Frame caption="Chain Abstraction Flow">
    <img src="/images/assets/chain-abstraction-flow.png" />
</Frame>

## Methods

<Info>
Make sure you are using canary version of `@reown/walletkit` and `@walletconnect/react-native-compat`
</Info>

Following are the methods from WalletKit that you will use in implementing chain abstraction.

### Prepare 

This method checks if a transaction requires additional bridging transactions beforehand.

```typescript
public prepare(params: {
  transaction: ChainAbstractionTypes.Transaction;
}): Promise<ChainAbstractionTypes.CanFulfilResponse>;
```

### Status 

Helper method used to check the fulfilment status of a bridging operation.

```typescript
public abstract status(params: {
  fulfilmentId: string;
}): Promise<ChainAbstractionTypes.FulfilmentStatusResponse>;
```

## Usage

When sending a transaction, first check if chain abstraction is needed using the `prepare` method. If it is needed, you must sign all the fulfillment transactions and use the `execute` method. 

If the operation is successful, use `execute` method and await the transaction hash and receipt. 
If the operation is unsuccessful, send the JsonRpcError to the dapp and display the error to the user. 

```typescript
const initialTransaction = {
  // ... transaction details
};

const prepareResponse = await WalletKit.ChainAbstraction.prepare(initialTransaction);

if (prepareResponse.type === 'Available') {
  // Sign all the fulfilment transactions and init transaction
  // Use execute method
  
  try {
    const executeResponse = await WalletKit.ChainAbstraction.execute(
      prepareResponse,
      prepareSignedTxs,
      initSignedTx
    );
    
    // The execution of the Chain Abstraction is successful
    // Send the response to the Dapp
  } catch (error) {
    // Execute error - wallet should send the JsonRpcError to a dapp for given request and display error to the user
  }
} else if (prepareResponse.type === 'NotRequired') {
  // Chain abstraction is not required, handle transaction as usual
} else {
  // One of the possible errors: NoRoutesAvailable, InsufficientFunds, InsufficientGasFunds
  // Wallet should send the JsonRpcError to a dapp for given request and display error to the user
}
```

For example, check out implementation of chain abstraction in [sample wallet](https://github.com/WalletConnect/WalletConnectKotlinV2/tree/master/sample/wallet) with Kotlin. 

## Error Handling

When implementing Chain Abstraction, you may encounter different types of errors. Here's how to handle them effectively:

### Application-Level Errors

These errors (`PrepareDetailedResponse::Err`) indicate specific issues that need to be addressed and typically require user action:

- **Insufficient Gas Fees**: User needs to add more gas tokens to their wallet
- **Malformed Transaction Requests**: Transaction parameters are invalid or incomplete
- **Minimum Bridging Amount Not Met**: Currently set at $0.60
- **Invalid Token or Network Selection**: Selected token or network is not supported

When handling these errors, you should display clear, user-friendly error messages that provide specific guidance on how to resolve the issue. Allow users to modify their transaction parameters and consider implementing validation checks before initiating transactions.

### Retryable Errors

These errors (`Result::Err`) indicate temporary issues that may be resolved by retrying the operation:

- **Local Network Issues**: DNS blocks, TLS inspection, TCP timeouts
- **Server Issues**: 5xx errors, service outages
- **Race Conditions**: Concurrent transaction conflicts
- **Temporary RPC Errors**: Network connectivity issues

For retryable errors, show a generic "oops" message to users and provide a retry button. Log detailed error information to your error tracking service, but avoid displaying technical details to end users.

<Note>
For errors in the `execute()` method, a retry may not resolve the issue. In such cases, allow users to cancel the transaction, return them to the application, and let the application initiate a new transaction.
</Note>

### Critical Errors

Critical errors indicate bugs or implementation issues that should be treated as high-priority incidents:

- **Unexpected State Transitions**: Invalid state changes in the transaction flow
- **Contract Interaction Failures**: Issues with smart contract interactions
- **Bridge Protocol Errors**: Problems with the bridging protocol implementation
- **Security Violations**: Potential security-related issues

From the user's perspective, treat these as retryable errors, but ensure you log the incident immediately for investigation and implement appropriate error tracking and monitoring.

## Testing 

To test Chain Abstraction, you can use the [AppKit laboratory](https://appkit-lab.reown.com/library/wagmi/) and try sending any supported [tokens](../../../walletkit/features/early-access/chain-abstraction.mdx#what-are-the-supported-tokens-and-networks) with any chain abstraction supported wallet. 
You can also use this [sample wallet](https://appdistribution.firebase.dev/i/076a3bc9669d3bee) for testing. 

<video controls width="100%" height="100%" style={{ borderRadius: '10px' }}>
  <source src="/assets/chain-abstraction-demo.mp4" type="video/mp4" />
</video>

## Types

Following are the types that are used in the chain abstraction methods.

```typescript
namespace ChainAbstractionTypes {
  type FundingFrom = {
    tokenContract: string;
    amount: string;
    chainId: string;
    symbol: string;
  };

  type Transaction = {
    from: string;
    to: string;
    value: string;
    chainId: string;
    gas?: string;
    gasPrice?: string;
    data?: string;
    nonce?: string;
    maxFeePerGas?: string;
    maxPriorityFeePerGas?: string;
  };

  type CanFulfilResponse =
    | {
        status: "not_required";
      }
    | {
        status: "available";
        data: {
          fulfilmentId: string;
          checkIn: number;
          transactions: Transaction[];
          funding: FundingFrom[];
        };
      }
    | {
        status: "error";
        reason: string; // reason can be insufficientFunds | insufficientGasFunds | noRoutesAvailable
      };

  type FulfilmentStatusResponse = {
    createdAt: number;
  } & (
    | {
        status: "completed";
      }
    | { status: "pending"; checkIn: number }
  );
}
```

For example, check out implementation of chain abstraction in [sample wallet](https://github.com/reown-com/react-native-examples/pull/185) with React Native CLI. 
